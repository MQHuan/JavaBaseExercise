package com.teacher.javabase.javabaseexercise.demo;


import com.teacher.javabase.javabaseexercise.DemoBaseActivity;

public class TwentyThirdDayDemoActivity extends DemoBaseActivity {



  public void testMain() {

  }

  public void testConclusion(){
    /*
1：多线程(理解)
(1)就是应用程序有多条执行路径。
  进程：就是正在运行的程序。
  线程：就是进程的执行路径，执行单元。

(2)如何使用多线程程序：(掌握)
  A:方式1 继承Thread类。
      a:创建类继承Thread类
      b:重写Thread类的run()方法。
          run()方法里面才是封装线程的代码。
      c:通过调用start()方法启动线程并调用run()方法。

B:方式2	实现Runnable接口
      a:创建一个类实现Runnable接口
      b:重写run()方法
      c:创建实现类对象，并把它作为参数传递给Thread类的构造方法，创建Thread对象
      d:通过Thread的对象执行

线程安全问题的解决方案：
  A:同步代码块
      synchronized(锁对象)
      {
          被同步的代码
      }
  B:同步方法
      把synchronized加在方法上。

进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。

　　线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。

　　线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

　　多进程是指操作系统能同时运行多个任务（程序）。

　　多线程是指在同一程序中有多个顺序流在执行。

在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。

多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。

Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，
以留出一定时间给其他线程执行的机会。

实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。

run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。
Thread类实际上也是实现了Runnable接口的类。

在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，
然后调用Thread对象的start()方法来运行多线程代码。

实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，
最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

总结：


实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立




main方法其实也是一个线程。
在java中所以的线程都是同时启动的，至于什么时候，
哪个先执行，完全看谁先得到CPU的资源。



在java中，每次程序运行至少启动2个线程。
一个是main线程，一个是垃圾收集线程。
因为每当使用java命令执行一个类的时候，
实际上都会启动一个ＪＶＭ，
每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。

1、新建状态（New）：新创建了一个线程对象。

2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。

4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。

（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。

（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

线程的调度

1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。



Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：

static int MAX_PRIORITY

          线程可以具有的最高优先级，取值为10。

static int MIN_PRIORITY

          线程可以具有的最低优先级，取值为1。

static int NORM_PRIORITY

          分配给线程的默认优先级，取值为5。



Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。



每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。

线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。

JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。
如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，
这样能保证同样的优先级采用了同样的调度方式。



2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，
以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。



3、线程等待：Object类中的wait()方法，导致当前的线程等待，
直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。
这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。



4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，
把执行机会让给相同或者更高优先级的线程。



5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，
则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。



6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。
如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，
并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。
 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
 例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。
 类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。

 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。
    * */
  }


}
